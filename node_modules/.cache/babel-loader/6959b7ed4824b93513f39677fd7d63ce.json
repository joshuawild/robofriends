{"ast":null,"code":"/* Copyright 2015-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\nvar EE = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar os = require('os');\n\nvar assert = require('assert');\n\nvar Int64 = require('node-int64'); // BSER uses the local endianness to reduce byte swapping overheads\n// (the protocol is expressly local IPC only).  We need to tell node\n// to use the native endianness when reading various native values.\n\n\nvar isBigEndian = os.endianness() == 'BE'; // Find the next power-of-2 >= size\n\nfunction nextPow2(size) {\n  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));\n} // Expandable buffer that we can provide a size hint for\n\n\nfunction Accumulator(initsize) {\n  this.buf = new Buffer(nextPow2(initsize || 8192));\n  this.readOffset = 0;\n  this.writeOffset = 0;\n} // For testing\n\n\nexports.Accumulator = Accumulator; // How much we can write into this buffer without allocating\n\nAccumulator.prototype.writeAvail = function () {\n  return this.buf.length - this.writeOffset;\n}; // How much we can read\n\n\nAccumulator.prototype.readAvail = function () {\n  return this.writeOffset - this.readOffset;\n}; // Ensure that we have enough space for size bytes\n\n\nAccumulator.prototype.reserve = function (size) {\n  if (size < this.writeAvail()) {\n    return;\n  } // If we can make room by shunting down, do so\n\n\n  if (this.readOffset > 0) {\n    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);\n    this.writeOffset -= this.readOffset;\n    this.readOffset = 0;\n  } // If we made enough room, no need to allocate more\n\n\n  if (size < this.writeAvail()) {\n    return;\n  } // Allocate a replacement and copy it in\n\n\n  var buf = new Buffer(nextPow2(this.buf.length + size - this.writeAvail()));\n  this.buf.copy(buf);\n  this.buf = buf;\n}; // Append buffer or string.  Will resize as needed\n\n\nAccumulator.prototype.append = function (buf) {\n  if (Buffer.isBuffer(buf)) {\n    this.reserve(buf.length);\n    buf.copy(this.buf, this.writeOffset, 0, buf.length);\n    this.writeOffset += buf.length;\n  } else {\n    var size = Buffer.byteLength(buf);\n    this.reserve(size);\n    this.buf.write(buf, this.writeOffset);\n    this.writeOffset += size;\n  }\n};\n\nAccumulator.prototype.assertReadableSize = function (size) {\n  if (this.readAvail() < size) {\n    throw new Error(\"wanted to read \" + size + \" bytes but only have \" + this.readAvail());\n  }\n};\n\nAccumulator.prototype.peekString = function (size) {\n  this.assertReadableSize(size);\n  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);\n};\n\nAccumulator.prototype.readString = function (size) {\n  var str = this.peekString(size);\n  this.readOffset += size;\n  return str;\n};\n\nAccumulator.prototype.peekInt = function (size) {\n  this.assertReadableSize(size);\n\n  switch (size) {\n    case 1:\n      return this.buf.readInt8(this.readOffset, size);\n\n    case 2:\n      return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);\n\n    case 4:\n      return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);\n\n    case 8:\n      var big = this.buf.slice(this.readOffset, this.readOffset + 8);\n\n      if (isBigEndian) {\n        // On a big endian system we can simply pass the buffer directly\n        return new Int64(big);\n      } // Otherwise we need to byteswap\n\n\n      return new Int64(byteswap64(big));\n\n    default:\n      throw new Error(\"invalid integer size \" + size);\n  }\n};\n\nAccumulator.prototype.readInt = function (bytes) {\n  var ival = this.peekInt(bytes);\n  this.readOffset += bytes;\n  return ival;\n};\n\nAccumulator.prototype.peekDouble = function () {\n  this.assertReadableSize(8);\n  return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);\n};\n\nAccumulator.prototype.readDouble = function () {\n  var dval = this.peekDouble();\n  this.readOffset += 8;\n  return dval;\n};\n\nAccumulator.prototype.readAdvance = function (size) {\n  if (size > 0) {\n    this.assertReadableSize(size);\n  } else if (size < 0 && this.readOffset + size < 0) {\n    throw new Error(\"advance with negative offset \" + size + \" would seek off the start of the buffer\");\n  }\n\n  this.readOffset += size;\n};\n\nAccumulator.prototype.writeByte = function (value) {\n  this.reserve(1);\n  this.buf.writeInt8(value, this.writeOffset);\n  ++this.writeOffset;\n};\n\nAccumulator.prototype.writeInt = function (value, size) {\n  this.reserve(size);\n\n  switch (size) {\n    case 1:\n      this.buf.writeInt8(value, this.writeOffset);\n      break;\n\n    case 2:\n      if (isBigEndian) {\n        this.buf.writeInt16BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt16LE(value, this.writeOffset);\n      }\n\n      break;\n\n    case 4:\n      if (isBigEndian) {\n        this.buf.writeInt32BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt32LE(value, this.writeOffset);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"unsupported integer size \" + size);\n  }\n\n  this.writeOffset += size;\n};\n\nAccumulator.prototype.writeDouble = function (value) {\n  this.reserve(8);\n\n  if (isBigEndian) {\n    this.buf.writeDoubleBE(value, this.writeOffset);\n  } else {\n    this.buf.writeDoubleLE(value, this.writeOffset);\n  }\n\n  this.writeOffset += 8;\n};\n\nvar BSER_ARRAY = 0x00;\nvar BSER_OBJECT = 0x01;\nvar BSER_STRING = 0x02;\nvar BSER_INT8 = 0x03;\nvar BSER_INT16 = 0x04;\nvar BSER_INT32 = 0x05;\nvar BSER_INT64 = 0x06;\nvar BSER_REAL = 0x07;\nvar BSER_TRUE = 0x08;\nvar BSER_FALSE = 0x09;\nvar BSER_NULL = 0x0a;\nvar BSER_TEMPLATE = 0x0b;\nvar BSER_SKIP = 0x0c;\nvar ST_NEED_PDU = 0; // Need to read and decode PDU length\n\nvar ST_FILL_PDU = 1; // Know the length, need to read whole content\n\nvar MAX_INT8 = 127;\nvar MAX_INT16 = 32768;\nvar MAX_INT32 = 2147483648;\n\nfunction BunserBuf() {\n  EE.call(this);\n  this.buf = new Accumulator();\n  this.state = ST_NEED_PDU;\n}\n\nutil.inherits(BunserBuf, EE);\nexports.BunserBuf = BunserBuf;\n\nBunserBuf.prototype.append = function (buf, synchronous) {\n  if (synchronous) {\n    this.buf.append(buf);\n    return this.process(synchronous);\n  }\n\n  try {\n    this.buf.append(buf);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  } // Arrange to decode later.  This allows the consuming\n  // application to make progress with other work in the\n  // case that we have a lot of subscription updates coming\n  // in from a large tree.\n\n\n  this.processLater();\n};\n\nBunserBuf.prototype.processLater = function () {\n  var self = this;\n  process.nextTick(function () {\n    try {\n      self.process(false);\n    } catch (err) {\n      self.emit('error', err);\n    }\n  });\n}; // Do something with the buffer to advance our state.\n// If we're running synchronously we'll return either\n// the value we've decoded or undefined if we don't\n// yet have enought data.\n// If we're running asynchronously, we'll emit the value\n// when it becomes ready and schedule another invocation\n// of process on the next tick if we still have data we\n// can process.\n\n\nBunserBuf.prototype.process = function (synchronous) {\n  if (this.state == ST_NEED_PDU) {\n    if (this.buf.readAvail() < 2) {\n      return;\n    } // Validate BSER header\n\n\n    this.expectCode(0);\n    this.expectCode(1);\n    this.pduLen = this.decodeInt(true\n    /* relaxed */\n    );\n\n    if (this.pduLen === false) {\n      // Need more data, walk backwards\n      this.buf.readAdvance(-2);\n      return;\n    } // Ensure that we have a big enough buffer to read the rest of the PDU\n\n\n    this.buf.reserve(this.pduLen);\n    this.state = ST_FILL_PDU;\n  }\n\n  if (this.state == ST_FILL_PDU) {\n    if (this.buf.readAvail() < this.pduLen) {\n      // Need more data\n      return;\n    } // We have enough to decode it\n\n\n    var val = this.decodeAny();\n\n    if (synchronous) {\n      return val;\n    }\n\n    this.emit('value', val);\n    this.state = ST_NEED_PDU;\n  }\n\n  if (!synchronous && this.buf.readAvail() > 0) {\n    this.processLater();\n  }\n};\n\nBunserBuf.prototype.raise = function (reason) {\n  throw new Error(reason + \", in Buffer of length \" + this.buf.buf.length + \" (\" + this.buf.readAvail() + \" readable) at offset \" + this.buf.readOffset + \" buffer: \" + JSON.stringify(this.buf.buf.slice(this.buf.readOffset, this.buf.readOffset + 32).toJSON()));\n};\n\nBunserBuf.prototype.expectCode = function (expected) {\n  var code = this.buf.readInt(1);\n\n  if (code != expected) {\n    this.raise(\"expected bser opcode \" + expected + \" but got \" + code);\n  }\n};\n\nBunserBuf.prototype.decodeAny = function () {\n  var code = this.buf.peekInt(1);\n\n  switch (code) {\n    case BSER_INT8:\n    case BSER_INT16:\n    case BSER_INT32:\n    case BSER_INT64:\n      return this.decodeInt();\n\n    case BSER_REAL:\n      this.buf.readAdvance(1);\n      return this.buf.readDouble();\n\n    case BSER_TRUE:\n      this.buf.readAdvance(1);\n      return true;\n\n    case BSER_FALSE:\n      this.buf.readAdvance(1);\n      return false;\n\n    case BSER_NULL:\n      this.buf.readAdvance(1);\n      return null;\n\n    case BSER_STRING:\n      return this.decodeString();\n\n    case BSER_ARRAY:\n      return this.decodeArray();\n\n    case BSER_OBJECT:\n      return this.decodeObject();\n\n    case BSER_TEMPLATE:\n      return this.decodeTemplate();\n\n    default:\n      this.raise(\"unhandled bser opcode \" + code);\n  }\n};\n\nBunserBuf.prototype.decodeArray = function () {\n  this.expectCode(BSER_ARRAY);\n  var nitems = this.decodeInt();\n  var arr = [];\n\n  for (var i = 0; i < nitems; ++i) {\n    arr.push(this.decodeAny());\n  }\n\n  return arr;\n};\n\nBunserBuf.prototype.decodeObject = function () {\n  this.expectCode(BSER_OBJECT);\n  var nitems = this.decodeInt();\n  var res = {};\n\n  for (var i = 0; i < nitems; ++i) {\n    var key = this.decodeString();\n    var val = this.decodeAny();\n    res[key] = val;\n  }\n\n  return res;\n};\n\nBunserBuf.prototype.decodeTemplate = function () {\n  this.expectCode(BSER_TEMPLATE);\n  var keys = this.decodeArray();\n  var nitems = this.decodeInt();\n  var arr = [];\n\n  for (var i = 0; i < nitems; ++i) {\n    var obj = {};\n\n    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {\n      if (this.buf.peekInt(1) == BSER_SKIP) {\n        this.buf.readAdvance(1);\n        continue;\n      }\n\n      var val = this.decodeAny();\n      obj[keys[keyidx]] = val;\n    }\n\n    arr.push(obj);\n  }\n\n  return arr;\n};\n\nBunserBuf.prototype.decodeString = function () {\n  this.expectCode(BSER_STRING);\n  var len = this.decodeInt();\n  return this.buf.readString(len);\n}; // This is unusual compared to the other decode functions in that\n// we may not have enough data available to satisfy the read, and\n// we don't want to throw.  This is only true when we're reading\n// the PDU length from the PDU header; we'll set relaxSizeAsserts\n// in that case.\n\n\nBunserBuf.prototype.decodeInt = function (relaxSizeAsserts) {\n  if (relaxSizeAsserts && !this.buf.readAvail(1)) {\n    return false;\n  } else {\n    this.buf.assertReadableSize(1);\n  }\n\n  var code = this.buf.peekInt(1);\n  var size = 0;\n\n  switch (code) {\n    case BSER_INT8:\n      size = 1;\n      break;\n\n    case BSER_INT16:\n      size = 2;\n      break;\n\n    case BSER_INT32:\n      size = 4;\n      break;\n\n    case BSER_INT64:\n      size = 8;\n      break;\n\n    default:\n      this.raise(\"invalid bser int encoding \" + code);\n  }\n\n  if (relaxSizeAsserts && !this.buf.readAvail(1 + size)) {\n    return false;\n  }\n\n  this.buf.readAdvance(1);\n  return this.buf.readInt(size);\n}; // synchronously BSER decode a string and return the value\n\n\nfunction loadFromBuffer(input) {\n  var buf = new BunserBuf();\n  var result = buf.append(input, true);\n\n  if (buf.buf.readAvail()) {\n    throw Error('excess data found after input buffer, use BunserBuf instead');\n  }\n\n  if (typeof result === 'undefined') {\n    throw Error('no bser found in string and no error raised!?');\n  }\n\n  return result;\n}\n\nexports.loadFromBuffer = loadFromBuffer; // Byteswap an arbitrary buffer, flipping from one endian\n// to the other, returning a new buffer with the resultant data\n\nfunction byteswap64(buf) {\n  var swap = new Buffer(buf.length);\n\n  for (var i = 0; i < buf.length; i++) {\n    swap[i] = buf[buf.length - 1 - i];\n  }\n\n  return swap;\n}\n\nfunction dump_int64(buf, val) {\n  // Get the raw bytes.  The Int64 buffer is big endian\n  var be = val.toBuffer();\n\n  if (isBigEndian) {\n    // We're a big endian system, so the buffer is exactly how we\n    // want it to be\n    buf.writeByte(BSER_INT64);\n    buf.append(be);\n    return;\n  } // We need to byte swap to get the correct representation\n\n\n  var le = byteswap64(be);\n  buf.writeByte(BSER_INT64);\n  buf.append(le);\n}\n\nfunction dump_int(buf, val) {\n  var abs = Math.abs(val);\n\n  if (abs <= MAX_INT8) {\n    buf.writeByte(BSER_INT8);\n    buf.writeInt(val, 1);\n  } else if (abs <= MAX_INT16) {\n    buf.writeByte(BSER_INT16);\n    buf.writeInt(val, 2);\n  } else if (abs <= MAX_INT32) {\n    buf.writeByte(BSER_INT32);\n    buf.writeInt(val, 4);\n  } else {\n    dump_int64(buf, new Int64(val));\n  }\n}\n\nfunction dump_any(buf, val) {\n  switch (typeof val) {\n    case 'number':\n      buf.writeByte(BSER_REAL);\n      buf.writeDouble(val);\n      return;\n\n    case 'string':\n      buf.writeByte(BSER_STRING);\n      dump_int(buf, Buffer.byteLength(val));\n      buf.append(val);\n      return;\n\n    case 'boolean':\n      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);\n      return;\n\n    case 'object':\n      if (val === null) {\n        buf.writeByte(BSER_NULL);\n        return;\n      }\n\n      if (val instanceof Int64) {\n        dump_int64(buf, val);\n        return;\n      }\n\n      if (Array.isArray(val)) {\n        buf.writeByte(BSER_ARRAY);\n        dump_int(buf, val.length);\n\n        for (var i = 0; i < val.length; ++i) {\n          dump_any(buf, val[i]);\n        }\n\n        return;\n      }\n\n      buf.writeByte(BSER_OBJECT);\n      var keys = Object.keys(val); // First pass to compute number of defined keys\n\n      var num_keys = keys.length;\n\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n\n        if (typeof v == 'undefined') {\n          num_keys--;\n        }\n      }\n\n      dump_int(buf, num_keys);\n\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n\n        if (typeof v == 'undefined') {\n          // Don't include it\n          continue;\n        }\n\n        dump_any(buf, key);\n\n        try {\n          dump_any(buf, v);\n        } catch (e) {\n          throw new Error(e.message + ' (while serializing object property with name `' + key + \"')\");\n        }\n      }\n\n      return;\n\n    default:\n      throw new Error('cannot serialize type ' + typeof val + ' to BSER');\n  }\n} // BSER encode value and return a buffer of the contents\n\n\nfunction dumpToBuffer(val) {\n  var buf = new Accumulator(); // Build out the header\n\n  buf.writeByte(0);\n  buf.writeByte(1); // Reserve room for an int32 to hold our PDU length\n\n  buf.writeByte(BSER_INT32);\n  buf.writeInt(0, 4); // We'll come back and fill this in at the end\n\n  dump_any(buf, val); // Compute PDU length\n\n  var off = buf.writeOffset;\n  var len = off - 7\n  /* the header length */\n  ;\n  buf.writeOffset = 3; // The length value to fill in\n\n  buf.writeInt(len, 4); // write the length in the space we reserved\n\n  buf.writeOffset = off;\n  return buf.buf.slice(0, off);\n}\n\nexports.dumpToBuffer = dumpToBuffer;","map":{"version":3,"sources":["/Users/jwild/Documents/GitHub/robofriends/node_modules/tachyon/node_modules/bser/index.js"],"names":["EE","require","EventEmitter","util","os","assert","Int64","isBigEndian","endianness","nextPow2","size","Math","pow","ceil","log","LN2","Accumulator","initsize","buf","Buffer","readOffset","writeOffset","exports","prototype","writeAvail","length","readAvail","reserve","copy","append","isBuffer","byteLength","write","assertReadableSize","Error","peekString","toString","readString","str","peekInt","readInt8","readInt16BE","readInt16LE","readInt32BE","readInt32LE","big","slice","byteswap64","readInt","bytes","ival","peekDouble","readDoubleBE","readDoubleLE","readDouble","dval","readAdvance","writeByte","value","writeInt8","writeInt","writeInt16BE","writeInt16LE","writeInt32BE","writeInt32LE","writeDouble","writeDoubleBE","writeDoubleLE","BSER_ARRAY","BSER_OBJECT","BSER_STRING","BSER_INT8","BSER_INT16","BSER_INT32","BSER_INT64","BSER_REAL","BSER_TRUE","BSER_FALSE","BSER_NULL","BSER_TEMPLATE","BSER_SKIP","ST_NEED_PDU","ST_FILL_PDU","MAX_INT8","MAX_INT16","MAX_INT32","BunserBuf","call","state","inherits","synchronous","process","err","emit","processLater","self","nextTick","expectCode","pduLen","decodeInt","val","decodeAny","raise","reason","JSON","stringify","toJSON","expected","code","decodeString","decodeArray","decodeObject","decodeTemplate","nitems","arr","i","push","res","key","keys","obj","keyidx","len","relaxSizeAsserts","loadFromBuffer","input","result","swap","dump_int64","be","toBuffer","le","dump_int","abs","dump_any","Array","isArray","Object","num_keys","v","e","message","dumpToBuffer","off"],"mappings":"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","sourcesContent":["/* Copyright 2015-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\n\nvar EE = require('events').EventEmitter;\nvar util = require('util');\nvar os = require('os');\nvar assert = require('assert');\nvar Int64 = require('node-int64');\n\n// BSER uses the local endianness to reduce byte swapping overheads\n// (the protocol is expressly local IPC only).  We need to tell node\n// to use the native endianness when reading various native values.\nvar isBigEndian = os.endianness() == 'BE';\n\n// Find the next power-of-2 >= size\nfunction nextPow2(size) {\n  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));\n}\n\n// Expandable buffer that we can provide a size hint for\nfunction Accumulator(initsize) {\n  this.buf = new Buffer(nextPow2(initsize || 8192));\n  this.readOffset = 0;\n  this.writeOffset = 0;\n}\n// For testing\nexports.Accumulator = Accumulator\n\n// How much we can write into this buffer without allocating\nAccumulator.prototype.writeAvail = function() {\n  return this.buf.length - this.writeOffset;\n}\n\n// How much we can read\nAccumulator.prototype.readAvail = function() {\n  return this.writeOffset - this.readOffset;\n}\n\n// Ensure that we have enough space for size bytes\nAccumulator.prototype.reserve = function(size) {\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // If we can make room by shunting down, do so\n  if (this.readOffset > 0) {\n    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);\n    this.writeOffset -= this.readOffset;\n    this.readOffset = 0;\n  }\n\n  // If we made enough room, no need to allocate more\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // Allocate a replacement and copy it in\n  var buf = new Buffer(nextPow2(this.buf.length + size - this.writeAvail()));\n  this.buf.copy(buf);\n  this.buf = buf;\n}\n\n// Append buffer or string.  Will resize as needed\nAccumulator.prototype.append = function(buf) {\n  if (Buffer.isBuffer(buf)) {\n    this.reserve(buf.length);\n    buf.copy(this.buf, this.writeOffset, 0, buf.length);\n    this.writeOffset += buf.length;\n  } else {\n    var size = Buffer.byteLength(buf);\n    this.reserve(size);\n    this.buf.write(buf, this.writeOffset);\n    this.writeOffset += size;\n  }\n}\n\nAccumulator.prototype.assertReadableSize = function(size) {\n  if (this.readAvail() < size) {\n    throw new Error(\"wanted to read \" + size +\n        \" bytes but only have \" + this.readAvail());\n  }\n}\n\nAccumulator.prototype.peekString = function(size) {\n  this.assertReadableSize(size);\n  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);\n}\n\nAccumulator.prototype.readString = function(size) {\n  var str = this.peekString(size);\n  this.readOffset += size;\n  return str;\n}\n\nAccumulator.prototype.peekInt = function(size) {\n  this.assertReadableSize(size);\n  switch (size) {\n    case 1:\n      return this.buf.readInt8(this.readOffset, size);\n    case 2:\n      return isBigEndian ?\n        this.buf.readInt16BE(this.readOffset, size) :\n        this.buf.readInt16LE(this.readOffset, size);\n    case 4:\n      return isBigEndian ?\n        this.buf.readInt32BE(this.readOffset, size) :\n        this.buf.readInt32LE(this.readOffset, size);\n    case 8:\n        var big = this.buf.slice(this.readOffset, this.readOffset + 8);\n        if (isBigEndian) {\n          // On a big endian system we can simply pass the buffer directly\n          return new Int64(big);\n        }\n        // Otherwise we need to byteswap\n        return new Int64(byteswap64(big));\n    default:\n      throw new Error(\"invalid integer size \" + size);\n  }\n}\n\nAccumulator.prototype.readInt = function(bytes) {\n  var ival = this.peekInt(bytes);\n  this.readOffset += bytes;\n  return ival;\n}\n\nAccumulator.prototype.peekDouble = function() {\n  this.assertReadableSize(8);\n  return isBigEndian ?\n    this.buf.readDoubleBE(this.readOffset) :\n    this.buf.readDoubleLE(this.readOffset);\n}\n\nAccumulator.prototype.readDouble = function() {\n  var dval = this.peekDouble();\n  this.readOffset += 8;\n  return dval;\n}\n\nAccumulator.prototype.readAdvance = function(size) {\n  if (size > 0) {\n    this.assertReadableSize(size);\n  } else if (size < 0 && this.readOffset + size < 0) {\n    throw new Error(\"advance with negative offset \" + size +\n        \" would seek off the start of the buffer\");\n  }\n  this.readOffset += size;\n}\n\nAccumulator.prototype.writeByte = function(value) {\n  this.reserve(1);\n  this.buf.writeInt8(value, this.writeOffset);\n  ++this.writeOffset;\n}\n\nAccumulator.prototype.writeInt = function(value, size) {\n  this.reserve(size);\n  switch (size) {\n    case 1:\n      this.buf.writeInt8(value, this.writeOffset);\n      break;\n    case 2:\n      if (isBigEndian) {\n        this.buf.writeInt16BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt16LE(value, this.writeOffset);\n      }\n      break;\n    case 4:\n      if (isBigEndian) {\n        this.buf.writeInt32BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt32LE(value, this.writeOffset);\n      }\n      break;\n    default:\n      throw new Error(\"unsupported integer size \" + size);\n  }\n  this.writeOffset += size;\n}\n\nAccumulator.prototype.writeDouble = function(value) {\n  this.reserve(8);\n  if (isBigEndian) {\n    this.buf.writeDoubleBE(value, this.writeOffset);\n  } else {\n    this.buf.writeDoubleLE(value, this.writeOffset);\n  }\n  this.writeOffset += 8;\n}\n\nvar BSER_ARRAY     = 0x00;\nvar BSER_OBJECT    = 0x01;\nvar BSER_STRING    = 0x02;\nvar BSER_INT8      = 0x03;\nvar BSER_INT16     = 0x04;\nvar BSER_INT32     = 0x05;\nvar BSER_INT64     = 0x06;\nvar BSER_REAL      = 0x07;\nvar BSER_TRUE      = 0x08;\nvar BSER_FALSE     = 0x09;\nvar BSER_NULL      = 0x0a;\nvar BSER_TEMPLATE  = 0x0b;\nvar BSER_SKIP      = 0x0c;\n\nvar ST_NEED_PDU = 0; // Need to read and decode PDU length\nvar ST_FILL_PDU = 1; // Know the length, need to read whole content\n\nvar MAX_INT8 = 127;\nvar MAX_INT16 = 32768;\nvar MAX_INT32 = 2147483648;\n\nfunction BunserBuf() {\n  EE.call(this);\n  this.buf = new Accumulator();\n  this.state = ST_NEED_PDU;\n}\nutil.inherits(BunserBuf, EE);\nexports.BunserBuf = BunserBuf;\n\nBunserBuf.prototype.append = function(buf, synchronous) {\n  if (synchronous) {\n    this.buf.append(buf);\n    return this.process(synchronous);\n  }\n\n  try {\n    this.buf.append(buf);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n  // Arrange to decode later.  This allows the consuming\n  // application to make progress with other work in the\n  // case that we have a lot of subscription updates coming\n  // in from a large tree.\n  this.processLater();\n}\n\nBunserBuf.prototype.processLater = function() {\n  var self = this;\n  process.nextTick(function() {\n    try {\n      self.process(false);\n    } catch (err) {\n      self.emit('error', err);\n    }\n  });\n}\n\n// Do something with the buffer to advance our state.\n// If we're running synchronously we'll return either\n// the value we've decoded or undefined if we don't\n// yet have enought data.\n// If we're running asynchronously, we'll emit the value\n// when it becomes ready and schedule another invocation\n// of process on the next tick if we still have data we\n// can process.\nBunserBuf.prototype.process = function(synchronous) {\n  if (this.state == ST_NEED_PDU) {\n    if (this.buf.readAvail() < 2) {\n      return;\n    }\n    // Validate BSER header\n    this.expectCode(0);\n    this.expectCode(1);\n    this.pduLen = this.decodeInt(true /* relaxed */);\n    if (this.pduLen === false) {\n      // Need more data, walk backwards\n      this.buf.readAdvance(-2);\n      return;\n    }\n    // Ensure that we have a big enough buffer to read the rest of the PDU\n    this.buf.reserve(this.pduLen);\n    this.state = ST_FILL_PDU;\n  }\n\n  if (this.state == ST_FILL_PDU) {\n    if (this.buf.readAvail() < this.pduLen) {\n      // Need more data\n      return;\n    }\n\n    // We have enough to decode it\n    var val = this.decodeAny();\n    if (synchronous) {\n      return val;\n    }\n    this.emit('value', val);\n    this.state = ST_NEED_PDU;\n  }\n\n  if (!synchronous && this.buf.readAvail() > 0) {\n    this.processLater();\n  }\n}\n\nBunserBuf.prototype.raise = function(reason) {\n  throw new Error(reason + \", in Buffer of length \" +\n      this.buf.buf.length + \" (\" + this.buf.readAvail() +\n      \" readable) at offset \" + this.buf.readOffset + \" buffer: \" +\n      JSON.stringify(this.buf.buf.slice(\n          this.buf.readOffset, this.buf.readOffset + 32).toJSON()));\n}\n\nBunserBuf.prototype.expectCode = function(expected) {\n  var code = this.buf.readInt(1);\n  if (code != expected) {\n    this.raise(\"expected bser opcode \" + expected + \" but got \" + code);\n  }\n}\n\nBunserBuf.prototype.decodeAny = function() {\n  var code = this.buf.peekInt(1);\n  switch (code) {\n    case BSER_INT8:\n    case BSER_INT16:\n    case BSER_INT32:\n    case BSER_INT64:\n      return this.decodeInt();\n    case BSER_REAL:\n      this.buf.readAdvance(1);\n      return this.buf.readDouble();\n    case BSER_TRUE:\n      this.buf.readAdvance(1);\n      return true;\n    case BSER_FALSE:\n      this.buf.readAdvance(1);\n      return false;\n    case BSER_NULL:\n      this.buf.readAdvance(1);\n      return null;\n    case BSER_STRING:\n      return this.decodeString();\n    case BSER_ARRAY:\n      return this.decodeArray();\n    case BSER_OBJECT:\n      return this.decodeObject();\n    case BSER_TEMPLATE:\n      return this.decodeTemplate();\n    default:\n      this.raise(\"unhandled bser opcode \" + code);\n  }\n}\n\nBunserBuf.prototype.decodeArray = function() {\n  this.expectCode(BSER_ARRAY);\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    arr.push(this.decodeAny());\n  }\n  return arr;\n}\n\nBunserBuf.prototype.decodeObject = function() {\n  this.expectCode(BSER_OBJECT);\n  var nitems = this.decodeInt();\n  var res = {};\n  for (var i = 0; i < nitems; ++i) {\n    var key = this.decodeString();\n    var val = this.decodeAny();\n    res[key] = val;\n  }\n  return res;\n}\n\nBunserBuf.prototype.decodeTemplate = function() {\n  this.expectCode(BSER_TEMPLATE);\n  var keys = this.decodeArray();\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    var obj = {};\n    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {\n      if (this.buf.peekInt(1) == BSER_SKIP) {\n        this.buf.readAdvance(1);\n        continue;\n      }\n      var val = this.decodeAny();\n      obj[keys[keyidx]] = val;\n    }\n    arr.push(obj);\n  }\n  return arr;\n}\n\nBunserBuf.prototype.decodeString = function() {\n  this.expectCode(BSER_STRING);\n  var len = this.decodeInt();\n  return this.buf.readString(len);\n}\n\n// This is unusual compared to the other decode functions in that\n// we may not have enough data available to satisfy the read, and\n// we don't want to throw.  This is only true when we're reading\n// the PDU length from the PDU header; we'll set relaxSizeAsserts\n// in that case.\nBunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {\n  if (relaxSizeAsserts && !this.buf.readAvail(1)) {\n    return false;\n  } else {\n    this.buf.assertReadableSize(1);\n  }\n  var code = this.buf.peekInt(1);\n  var size = 0;\n  switch (code) {\n    case BSER_INT8:\n      size = 1;\n      break;\n    case BSER_INT16:\n      size = 2;\n      break;\n    case BSER_INT32:\n      size = 4;\n      break;\n    case BSER_INT64:\n      size = 8;\n      break;\n    default:\n      this.raise(\"invalid bser int encoding \" + code);\n  }\n\n  if (relaxSizeAsserts && !this.buf.readAvail(1 + size)) {\n    return false;\n  }\n  this.buf.readAdvance(1);\n  return this.buf.readInt(size);\n}\n\n// synchronously BSER decode a string and return the value\nfunction loadFromBuffer(input) {\n  var buf = new BunserBuf();\n  var result = buf.append(input, true);\n  if (buf.buf.readAvail()) {\n    throw Error(\n        'excess data found after input buffer, use BunserBuf instead');\n  }\n  if (typeof result === 'undefined') {\n    throw Error(\n        'no bser found in string and no error raised!?');\n  }\n  return result;\n}\nexports.loadFromBuffer = loadFromBuffer\n\n// Byteswap an arbitrary buffer, flipping from one endian\n// to the other, returning a new buffer with the resultant data\nfunction byteswap64(buf) {\n  var swap = new Buffer(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    swap[i] = buf[buf.length -1 - i];\n  }\n  return swap;\n}\n\nfunction dump_int64(buf, val) {\n  // Get the raw bytes.  The Int64 buffer is big endian\n  var be = val.toBuffer();\n\n  if (isBigEndian) {\n    // We're a big endian system, so the buffer is exactly how we\n    // want it to be\n    buf.writeByte(BSER_INT64);\n    buf.append(be);\n    return;\n  }\n  // We need to byte swap to get the correct representation\n  var le = byteswap64(be);\n  buf.writeByte(BSER_INT64);\n  buf.append(le);\n}\n\nfunction dump_int(buf, val) {\n  var abs = Math.abs(val);\n  if (abs <= MAX_INT8) {\n    buf.writeByte(BSER_INT8);\n    buf.writeInt(val, 1);\n  } else if (abs <= MAX_INT16) {\n    buf.writeByte(BSER_INT16);\n    buf.writeInt(val, 2);\n  } else if (abs <= MAX_INT32) {\n    buf.writeByte(BSER_INT32);\n    buf.writeInt(val, 4);\n  } else {\n    dump_int64(buf, new Int64(val));\n  }\n}\n\nfunction dump_any(buf, val) {\n  switch (typeof(val)) {\n    case 'number':\n      buf.writeByte(BSER_REAL);\n      buf.writeDouble(val);\n      return;\n    case 'string':\n      buf.writeByte(BSER_STRING);\n      dump_int(buf, Buffer.byteLength(val));\n      buf.append(val);\n      return;\n    case 'boolean':\n      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);\n      return;\n    case 'object':\n      if (val === null) {\n        buf.writeByte(BSER_NULL);\n        return;\n      }\n      if (val instanceof Int64) {\n        dump_int64(buf, val);\n        return;\n      }\n      if (Array.isArray(val)) {\n        buf.writeByte(BSER_ARRAY);\n        dump_int(buf, val.length);\n        for (var i = 0; i < val.length; ++i) {\n          dump_any(buf, val[i]);\n        }\n        return;\n      }\n      buf.writeByte(BSER_OBJECT);\n      var keys = Object.keys(val);\n\n      // First pass to compute number of defined keys\n      var num_keys = keys.length;\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof(v) == 'undefined') {\n          num_keys--;\n        }\n      }\n      dump_int(buf, num_keys);\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof(v) == 'undefined') {\n          // Don't include it\n          continue;\n        }\n        dump_any(buf, key);\n        try {\n          dump_any(buf, v);\n        } catch (e) {\n          throw new Error(\n            e.message + ' (while serializing object property with name `' +\n              key + \"')\");\n        }\n      }\n      return;\n\n    default:\n      throw new Error('cannot serialize type ' + typeof(val) + ' to BSER');\n  }\n}\n\n// BSER encode value and return a buffer of the contents\nfunction dumpToBuffer(val) {\n  var buf = new Accumulator();\n  // Build out the header\n  buf.writeByte(0);\n  buf.writeByte(1);\n  // Reserve room for an int32 to hold our PDU length\n  buf.writeByte(BSER_INT32);\n  buf.writeInt(0, 4); // We'll come back and fill this in at the end\n\n  dump_any(buf, val);\n\n  // Compute PDU length\n  var off = buf.writeOffset;\n  var len = off - 7 /* the header length */;\n  buf.writeOffset = 3; // The length value to fill in\n  buf.writeInt(len, 4); // write the length in the space we reserved\n  buf.writeOffset = off;\n\n  return buf.buf.slice(0, off);\n}\nexports.dumpToBuffer = dumpToBuffer"]},"metadata":{},"sourceType":"script"}